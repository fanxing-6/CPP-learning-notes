# 操作系统进程学习(Linux 内核学习笔记)

## 进程优先级

并非所有进程都具有相同的重要性。除了大多数我们所熟悉的进程优先级之外，进程还有不同的关键度类别，以满足不同需求。首先进程比较粗糙的划分，进程可以分为**实时进程** 和**非实时进程（普通进程）**。 



实时进程优先级（0-99）都比普通 进程的优先级（100-139）高。当系统中有实时进程运行时，普通进程几乎无法分到时间片（只能分到5%的CPU时间）。

![通过时间片运行进程](https://lzx-figure-bed.obs.dualstack.cn-north-4.myhuaweicloud.com/Figurebed/image-20210903161607827.png)



## 进程系统调用

​	讨论fork和exec系列系统调用的实现。通常这些调用不是由应用程序直接发出的，而是通过一个中间层调用，即负责与内核通信的C标准库。从用户状态切换到核心态的方法，依不同的体系结构而各有不同

用户发起一个新进程之后,CPU为进程分配资源,并将硬盘数据读到内存中去,但是用户进程是一个应用级程序,无法直接与CPU进行交互,所以通过系统调用(system_call),加载完成内核就会退出CPU,用户进程执行完毕后,内核进入CPU将用户进程移除,下一个同上![image-20210903163111488](https://lzx-figure-bed.obs.dualstack.cn-north-4.myhuaweicloud.com/Figurebed/image-20210903163111488.png)

1. 进程复制

   (1) fork是重量级调用，因为它建立了父进程的一个完整副本，然后作为子进程执行。 为减少与该调用相关的工作量，Linux使用了写时复制（copy-on-write)^1^技术。 

   (2) vfork类似于fork，但并不创建父进程数据的副本。相反，父子进程之间共享数据。 这节省了大量CPU时间（如果一个进程操纵共享数据，则另一个会自动注意到）。 

   (3) clone产生线程，可以对父子进程之间的共享、复制进行精确控制。



[^1]: ![image-20210903182906481](https://lzx-figure-bed.obs.dualstack.cn-north-4.myhuaweicloud.com/Figurebed/image-20210903182906481.png)



